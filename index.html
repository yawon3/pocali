<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>pocalist</title>
  <link rel="stylesheet" href="/static/style.css">
</head>
<body>
        <!-- 상단 검색창 & 카운터 -->
        <header id="search-header">
          <input type="text" id="search-input" placeholder="포토카드 검색..." />
          <button id="search-detail-btn">+</button>
          <div id="count-display" style="text-align:center; font-weight:bold; margin-top: 5px;">
            0 / 0
          </div>
          <button id="view-toggle">👥 친구보기</button>  <!-- ← 새 버튼 -->
        </header>
  <!-- 카드 그리드 -->        
	<div id="photo-grid">  
    </div>
    <!-- 카드 상세 모달 -->
    <div id="photo-modal" class="modal" style="display: none;">
     <div class="modal-content">
      <span id="modal-close" class="close">&times;</span>
      <img id="modal-image" src="" alt="확대된 포토카드" draggable="false" />
      <div id="modal-info">
        <!-- 파일명 파싱 등으로 추후 상세 정보를 표시할 예정 -->
        </div>
      </div>
    </div>
    <!-- 유저 데이터 모달 -->
   <div id="user-data-modal" class="modal" style="display: none;">
   <div class="modal-content">
    <span id="user-data-modal-close" class="close">&times;</span>
    <h3>UUID 데이터 관리</h3>

    <!-- 내 UUID 영역 -->
    <label for="my-uuid">내 UUID:</label>
    <input type="text" id="my-uuid" readonly style="width: 100%;" />

    <!-- 다른 기기의 UUID 입력 영역 -->
    <label for="other-uuid">다른 기기의 UUID 불러오기:</label>
    <input type="text" id="other-uuid" placeholder="다른 디바이스의 UUID 입력" style="width: 100%;" />
    <button id="load-other-data">데이터 불러오기</button>

    <!-- 메시지 또는 에러 표시 -->
    <div id="uuid-msg" style="margin-top: 10px; color: red;"></div>
    </div>
   </div>

         <!-- 상세 검색 모달 -->
        <div id="detail-search-modal" class="modal" style="display: none;">
            <div class="modal-content">
            <span id="detail-search-modal-close" class="close">&times;</span>
            <h3>상세 검색 옵션</h3>
            <form id="detail-search-form">
                <fieldset>
                <legend>그룹</legend>
                <label>
                    <input type="checkbox" name="group" value="IVE" />
                    아이브
                </label>
                <label>
                    <input type="checkbox" name="group" value="IZONE" />
                    아이즈원
                </label>
                </fieldset>
                <fieldset>
                <legend>멤버</legend>
                <label>
                    <input type="checkbox" name="member" value="유진" />
                    유진
                </label>
                <label>
                    <input type="checkbox" name="member" value="가을" />
                    가을
                </label>
                <label>
                    <input type="checkbox" name="member" value="레이" />
                    레이
                </label>
                <label>
                    <input type="checkbox" name="member" value="원영" />
                    원영
                </label>
                <label>
                    <input type="checkbox" name="member" value="리즈" />
                    리즈
                </label>
                <label>
                    <input type="checkbox" name="member" value="이서" />
                    이서
                </label>
                </fieldset>
                <fieldset>
                <legend>텍스트 검색</legend>
                <input type="text" id="filter-text" name="filter-text" placeholder="검색어 입력" />
                </fieldset>
                <button type="submit">검색</button>
            </form>
            </div>
        </div>
        <!-- 이미지 시트 출력 모달 -->
        <div id="export-modal" class="modal" style="display: none;">
          <div class="modal-content">
              <span id="export-modal-close" class="close">&times;</span>
              <h3>포토카드 시트 출력</h3>
              <form id="export-form">
                  <fieldset>
                      <legend>그룹 선택</legend>
                      <label><input type="radio" name="group" value="IVE" checked> 아이브</label>
                      <label><input type="radio" name="group" value="IZONE"> 아이즈원</label>
                  </fieldset>
                  <fieldset>
                      <legend>멤버 선택</legend>
                      <label><input type="checkbox" name="member" value="유진"> 유진</label>
                      <label><input type="checkbox" name="member" value="가을"> 가을</label>
                      <label><input type="checkbox" name="member" value="레이"> 레이</label>
                      <label><input type="checkbox" name="member" value="원영"> 원영</label>
                      <label><input type="checkbox" name="member" value="리즈"> 리즈</label>
                      <label><input type="checkbox" name="member" value="이서"> 이서</label>
                  </fieldset>
                  <button type="submit">시트 생성</button>
              </form>
          </div>
        </div>
          <!-- 친구 UUID 입력 모달 -->
         <div id="friend-modal" class="modal"><div class="modal-content">
          <span id="friend-modal-close" class="close">&times;</span>
          <h3>친구 UUID 입력</h3>
          <input id="friend-uuid" placeholder="친구 UUID" style="width:100%">
          <button id="friend-add-confirm">추가</button></div></div>

	<!-- 하단 우측 FAB 버튼 -->
        <button
        id="categoryToggleBtn"
        class="floating-btn left"
        title="카테고리별 보기"
      >🏷️</button>
        <button id="fab">+</button>
        <!-- FAB 모달: 유저 데이터/관리자 메뉴 -->
        <div id="user-modal" class="modal" style="display: none;">
            <div class="modal-content">
            <span id="user-modal-close" class="close">&times;</span>
            <h3>유저 데이터 및 관리자 메뉴</h3>
            <ul>
                <li><button id="load-user-data">유저 데이터 불러오기</button></li>
                <li><button id="reset-checks">체크 상태 초기화</button></li>
                <li><button id="export-sheet">이미지 시트 출력</button></li>
                <li><button id="add-friend">친구 추가</button></li>
            </ul>
            </div>
        </div>
       <!-- ✅ html2canvas 등 외부 라이브러리 로드 -->
        <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>

        <script>
          /* ==========================================================
             📌 pocalist 메인 스크립트
             (2024-04-28 - 리팩터: 가독성 ↑ / 중복 ↓)
             ========================================================== */
          
          /* ───────────────────────────────────────────────
             0. 전역 상태 및 도우미
             ─────────────────────────────────────────────── */
          // ─── 페이징용 전역 변수 ─────────────────────────
          const BATCH_SIZE   = 100;      // 한 번에 로드할 카드 개수
          let backupAllImages = [];       // allImages 원본 백업용
          let allImages      = [];       // 전체 이미지 메타데이터 저장
          let currentBatch   = 0;        // 렌더된 배치 인덱스
          let isRendering    = false;    // 중복 렌더링 방지 플래그
          let totalCount     = 0;        // ← 전체 개수 헤더에서 읽어 저장
          let currentView       = 'id';      // 'id'  | 'category'
          let viewOwner         = 'self';    // 'self'| 'friend'
          let currentFriendUUID = localStorage.getItem('lastFriendUUID') || null;
          
          const advancedFilters = { groups: [], members: [] };
          
          /* 짧은 셀렉터 도우미 */
          function $(sel,  scope=document) { return scope.querySelector(sel); }
          function $$(sel, scope=document) { return Array.from(scope.querySelectorAll(sel)); }

          /* ── 공통: 이미지 상세 모달 ───────────────────────── */
          function showModal(img) {
            const $modal      = $('#photo-modal');
            const $modalImg   = $('#modal-image');
            const $modalInfo  = $('#modal-info');

            $modalImg.src = img.src;

            $modalInfo.innerHTML = `
              <p>${img.dataset.group   || ''}</p>
              <p>${img.dataset.member  || ''}</p>
              <p>${img.dataset.category || ''} ${img.dataset.title || ''}</p>
              <p>${img.dataset.version || ''}</p>
              <p>#${img.dataset.unique}</p>
            `;

            $modal.style.display = 'block';
          }
            // 모달 전체에서 우클릭 메뉴 차단
            $('#photo-modal').addEventListener('contextmenu', e => e.preventDefault());

            // 모달 안 이미지에서도 우클릭 메뉴 차단
            $('#modal-image').addEventListener('contextmenu', e => e.preventDefault());



          /* X 버튼 -or- 바깥 클릭 → 모달 닫기 */
          $('#modal-close').addEventListener('click', () => $('#photo-modal').style.display = 'none');
          $('#photo-modal').addEventListener('click', e => {
            if (e.target === $('#photo-modal')) $('#photo-modal').style.display = 'none';
          });


          
          /* ───────────────────────────────────────────────
             1. DOMContentLoaded 이후 초기화
             ─────────────────────────────────────────────── */
           document.addEventListener('DOMContentLoaded', () => {
              // ── export-modal 닫기 핸들러 (딱 한 번)
              const $exportModal      = document.getElementById('export-modal');
              const $exportModalClose = document.getElementById('export-modal-close');
            
              // × 아이콘 클릭 시
              $exportModalClose.addEventListener('click', () => {
                $exportModal.style.display = 'none';
              });
              // 모달 바깥(overlay) 클릭 시
               $exportModal.addEventListener('click', e => {
                 if (e.target === $exportModal) {
                   $exportModal.style.display = 'none';
                 }
               });  // ← 이 줄을 꼭 추가!
              
            const LONG_PRESS     = 500;
            const TAP_THRESHOLD  = 200;
            const MOVE_THRESHOLD = 10;

             function toggleCheck(img) {
               img.classList.toggle('checked');
               const data = JSON.parse(localStorage.getItem('userData') || '{}');
               data[img.dataset.unique] = img.classList.contains('checked');
               localStorage.setItem('userData', JSON.stringify(data));
               syncLocalDataToServer();
               updateCount();
             }
            // ── ❶ toggleCheck 함수 정의 ...
             const $grid          = $('#photo-grid');
             const $viewToggleBtn = $('#view-toggle');
             const $catToggleBtn  = $('#categoryToggleBtn');
             const $searchInput   = $('#search-input');

             // 0. 렌더링 후에 값을 채울 변수들은 let 으로
             let originalCards = [];
             let photoCards    = [];
          
           async function fetchAndRenderImages() {
               // 1) 전체 이미지 메타데이터 + 전체 개수 가져오기
              const resp = await fetch('https://pocali-backend.onrender.com/api/images');
              allImages     = await resp.json();
              backupAllImages = allImages.slice();   // ← 원본 백업
              totalCount    = allImages.length;
              // 2) 첫 배치 렌더링 전 초기화
              currentBatch = 0;
              $grid.innerHTML = '';
              // 3) 첫 번째 배치(100장) 렌더링 호출
              renderNextBatch();
           }
          
           $searchInput.addEventListener('input', e => {
             const q = e.target.value.trim().toLowerCase();
             // empty 시 원본 복구, 아니면 필터링
             if (!q) {
               allImages = backupAllImages.slice();
             } else {
               allImages = backupAllImages.filter(meta =>
                 (`${meta.group} ${meta.member} ${meta.category} ${meta.title}`)
                   .toLowerCase().includes(q)
               );
             }
             // 페이징 초기화 후 다시 렌더
             currentBatch = 0;
             $grid.innerHTML = '';
             renderNextBatch();
          });

          $viewToggleBtn.addEventListener('click', () => {
            if (viewOwner === 'friend') loadSelfDeck();
            else if (currentFriendUUID) loadFriendDeck(currentFriendUUID);
            else alert('먼저 친구를 추가하세요!');
          });


          // 이제야 한 번만 이미지를 불러옵니다.
          fetchAndRenderImages()
            .catch(console.error);
   

                    
            /* ─────────────────────────────────────────────
               2. 공통 유틸
               ───────────────────────────────────────────── */
            /** 현재 화면의 총 카드수 / 보유카드수 표시 */
            function updateCount () {
              // “보유됨”은 로컬 userData 에 true인 것의 개수
              const data = JSON.parse(localStorage.getItem('userData') || '{}');
              const have = Object.values(data).filter(v => v).length;
              // “전체”는 헤더에서 읽은 totalCount
              document.getElementById('count-display').textContent = `${have} / ${totalCount}`;
            }
          
            /** 카드 리스트를 그리드에 그대로 렌더링 */
            function render(cards) {
              $grid.innerHTML = '';
              cards.forEach(c => $grid.appendChild(c));
              updateCount();
            }
          
            /* ─────────────────────────────────────────────
               3. 뷰 그리기(정렬) 함수
               ───────────────────────────────────────────── */
            /** 고유번호(ID) 내림차순 정렬 뷰 */
            function showById(list = null) {
              const cards = (list ?? originalCards).slice();   // 복사본
              cards.sort((a, b) =>
                $('.photo-card', b).dataset.unique -
                $('.photo-card', a).dataset.unique
              );
              render(cards);
            }
          
            /** 카테고리별 그룹 + 제목 + 버전 헤더 뷰 */
            function showByCategory () {
              const query = ($searchInput.value || '').toLowerCase();
              // originalCards 가 방금 렌더된 컨테이너들을 가리키고 있어야 합니다.
              /* (1) 필터링 */
              const filtered = originalCards.filter(div => {
                const img    = $('.photo-card', div);
                const alt    = img.alt.toLowerCase();
                const group  = img.dataset.group.toLowerCase();
                const member = img.dataset.member.toLowerCase();
          
                const textOK   = !query || alt.includes(query);
                const groupOK  = !advancedFilters.groups.length ||
                                 advancedFilters.groups.includes(group.toUpperCase());
                const memberOK = !advancedFilters.members.length ||
                                 advancedFilters.members.some(v => member.includes(v.toLowerCase()));
          
                return textOK && groupOK && memberOK;
              });
          
              /* (2) 그룹핑 ( category | title | version )*/
              const buckets = {};
              filtered.forEach(div => {
                const img  = $('.photo-card', div);
                const key  = [
                  img.dataset.category || '미분류',
                  img.dataset.title    || '',
                  img.dataset.version  || ''
                ].filter(Boolean).join(' | ');
                (buckets[key] = buckets[key] || []).push(div);
              });
          
              /* (3) 헤더 + 카드 렌더링 */
              $grid.innerHTML = '';
              Object.entries(buckets)
                .sort(([,a],[,b]) =>
                  +$('.photo-card', b[0]).dataset.unique -
                  +$('.photo-card', a[0]).dataset.unique
                )
                .forEach(([header, cards]) => {
                  const h2 = document.createElement('h2');
                  h2.textContent   = header;
                  h2.style.margin  = '16px 0 8px';
                  $grid.appendChild(h2);
          
                  cards.sort((a, b) =>
                    +$('.photo-card', b).dataset.unique -
                    +$('.photo-card', a).dataset.unique
                  ).forEach(div => $grid.appendChild(div));
                });
          
              updateCount();
            }
          
            /** 현재 필터/뷰 상태로 다시 그리기 */
            function applyFilters () {
                /* ② 공통 필터(검색어 + 상세조건) 한 번만 계산 */
              const query = ($searchInput.value || '').toLowerCase();

              const filtered = originalCards.filter(div => {
                const img    = $('.photo-card', div);
                const alt    = img.alt.toLowerCase();
                const group  = img.dataset.group.toLowerCase();
                const member = img.dataset.member.toLowerCase();

                const textOK   = !query || alt.includes(query);
                const groupOK  = !advancedFilters.groups.length ||
                                advancedFilters.groups.includes(group.toUpperCase());
                const memberOK = !advancedFilters.members.length ||
                                advancedFilters.members.some(v => member.includes(v.toLowerCase()));

                return textOK && groupOK && memberOK;
              });
              if (currentView === 'category') showByCategory(filtered);
              else                            showById(filtered);
            }

            
          
            /* ─────────────────────────────────────────────
               4. 덱 전환 (loadSelfDeck / loadFriendDeck)
               ───────────────────────────────────────────── */
            /** 내 보유 카드 표시 */
            function loadSelfDeck () {
              const myData = JSON.parse(localStorage.getItem('userData') || '{}');
              userData    = myData;                 // ← 전역 변수도 업데이트
              photoCards.forEach(img => {
                img.classList.toggle('checked', !!myData[img.dataset.unique]);
                img.style.pointerEvents = '';        // 더블클릭 허용
              });
          
              viewOwner   = 'self';
              $viewToggleBtn.textContent = '👥 친구보기';
              updateCount();
            }
          
            /** 친구 보유 카드 표시 */
            async function loadFriendDeck (uuid) {
              const res = await fetch(`https://pocali-backend.onrender.com/api/friend/${uuid}/collection`);
              if (!res.ok) {
                alert('친구 데이터를 불러올 수 없습니다.');
                return;
              }
          
              const friendData = (await res.json()).data || {};
              photoCards.forEach(img => {
                img.classList.toggle('checked', !!friendData[img.dataset.unique]);
                img.style.pointerEvents = 'none';   // 수정 금지
              });
          
              viewOwner         = 'friend';
              currentFriendUUID = uuid;
              localStorage.setItem('lastFriendUUID', uuid);
          
              $viewToggleBtn.textContent = '👤 내 카드보기';
              updateCount();
            }
          
            /* 전역(콘솔)에서도 호출할 수 있도록 */
            window.loadSelfDeck   = loadSelfDeck;
            window.loadFriendDeck = loadFriendDeck;
          
                       
          
            /* 5-2. “친구보기 ↔ 내카드보기” 토글 버튼 */
            $viewToggleBtn.addEventListener('click', () => {
              if (viewOwner === 'friend') loadSelfDeck();
              else if (currentFriendUUID) loadFriendDeck(currentFriendUUID);
              else alert('먼저 친구를 추가하세요!');
            });
          
            /* 5-3. 좌측 하단 카테고리/ID 전환 버튼 */
            $catToggleBtn.addEventListener('click', () => {
              currentView = currentView === 'id' ? 'category' : 'id';
              $catToggleBtn.textContent = currentView === 'id' ? '🏷️' : '🔢';
              $catToggleBtn.title       = currentView === 'id'
                                        ? '카테고리별 보기'
                                        : '고유번호 순 보기';
              applyFilters();
            });
          
            /* 5-4. 상단 검색 입력 */
            $searchInput.addEventListener('input', applyFilters);
          
            /* ─────────────────────────────────────────────
               6. 초기 랜더링
               ───────────────────────────────────────────── */
            showById();          // 기본 정렬
            loadSelfDeck();       // ✅ 보유표시도 함께!
            updateCount();       // 카운터 초기화
            /* 🔻 ❹ 서버→클라이언트 10초 폴링 ------------------------*/
            async function pollServerData () {
              if (viewOwner !== 'self') return;           // 친구 보기 땐 건너뜀
            
              const me = localStorage.getItem('myUUID');
              if (!me) return;
            
              const r = await fetch(`https://pocali-backend.onrender.com/api/user/${me}`);
              if (!r.ok) return;
              userData = JSON.parse((await r.json()).data || '{}');
              localStorage.setItem('userData', JSON.stringify(userData));
            
              photoCards.forEach(img =>
                img.classList.toggle('checked', !!userData[img.dataset.unique]));
              updateCount();
            }
            setInterval(pollServerData, 10_000);
            /* ------------------------------------------------------*/
            /* ── 5-A. 우측 FAB & 모달 보조 기능 ─────────────────────────── */
            const $fab           = $('#fab');
            const $userModal     = $('#user-modal');
            const $userModalClose= $('#user-modal-close');
            
            const $addFriendBtn  = $('#add-friend');
            const $friendModal   = $('#friend-modal');
            const $friendClose   = $('#friend-modal-close');
            const $friendConfirm = $('#friend-add-confirm');

            const $resetBtn      = $('#reset-checks');
            const $exportBtn     = $('#export-sheet');     // (시트 모달 열기만)

            const $userDataModal      = $('#user-data-modal');
            const $userDataModalClose = $('#user-data-modal-close');

            $userDataModalClose.addEventListener('click', () => $userDataModal.style.display = 'none');
            $userDataModal.addEventListener('click',  e => {      // 바깥 영역 클릭 시에도 닫힘
              if (e.target === $userDataModal) $userDataModal.style.display = 'none';
            });

            // 상세 검색 열기/닫기
            const detailBtn = document.getElementById('search-detail-btn');
            const detailModal = document.getElementById('detail-search-modal');
            const detailForm  = document.getElementById('detail-search-form');

            detailBtn.addEventListener('click', () => detailModal.style.display = 'block');
            detailModal.querySelector('.close').addEventListener('click', () => detailModal.style.display = 'none');
            detailModal.addEventListener('click', e => { if (e.target === detailModal) detailModal.style.display = 'none'; });

            // 폼 제출 시 필터 적용
             detailForm.addEventListener('submit', e => {
               e.preventDefault();
              const fd      = new FormData(detailForm);
               const groups  = fd.getAll('group');
               const members = fd.getAll('member');
            
               // ① allImages 전체에서 필터 적용
               if (!groups.length && !members.length) {
                 allImages = backupAllImages.slice();
               } else {
                 allImages = backupAllImages.filter(meta =>
                   (groups.length === 0 || groups.includes(meta.group)) &&
                   (members.length === 0 || members.includes(meta.member))
                 );
               }
            
               // ② 페이지네이션 초기화 + 첫 배치 렌더
               currentBatch = 0;
               $grid.innerHTML = '';
               renderNextBatch();
            
               // ③ 모달 닫기
               detailModal.style.display = 'none';
             });

              // ── export-form 요소 가져오기 (이 줄이 빠져 있었습니다)
              const $exportForm = document.getElementById('export-form');

             // ✅ 올바른 코드: export-form 값을 기준으로 allImages에서 필터
                $exportForm.addEventListener('submit', e => {
                e.preventDefault();
                const fd      = new FormData($exportForm);
                const group   = fd.get('group');
                const members = fd.getAll('member');

                const sel = backupAllImages.filter(meta =>
                  meta.group === group &&
                  (members.length === 0 || members.includes(meta.member))
                );
                if (!sel.length) {
                  return alert('선택하신 조건에 맞는 카드가 없습니다.');
                }
                  // 3) 메타→<img> 요소로 변환 (보유여부 반영)
               const nodes = sel.map(meta => {
                const img = document.createElement('img');
                img.className       = 'photo-card';
                img.crossOrigin     = 'anonymous';
                img.src             = meta.url;
                img.alt             = `${meta.group} ${meta.member} ${meta.category} ${meta.title}`;
                img.dataset.unique  = meta.unique_id;
                img.dataset.group   = meta.group;
                img.dataset.member  = meta.member;
                img.dataset.category= meta.category;
                img.dataset.title   = meta.title;
                img.dataset.version = meta.version;
                const ud = JSON.parse(localStorage.getItem('userData')||'{}');
                if (ud[meta.unique_id]) img.classList.add('checked');
                return img;
              });

          
              // 3) 모달 숨기고 시트 생성
              $exportModal.style.display = 'none';
              generateImageSheet(nodes);
            });
               

            /* 🔻 ❺ 다른 UUID 불러오기 --------------------------------*/
            $('#load-other-data')?.addEventListener('click', async () => {
              const other = $('#other-uuid').value.trim();
              if (!other) return alert('UUID를 입력하세요!');
              const r = await fetch(`https://pocali-backend.onrender.com/api/user/${other}`);
              if (!r.ok) return alert('해당 UUID를 찾을 수 없습니다.');
              const json = await r.json();
              localStorage.setItem('userData', json.data);
              localStorage.setItem('myUUID',   other);
              location.reload();                 // ← 바로 적용
            });
            /* -------------------------------------------------------*/
            /* 🔻 ❺-B : 유저 데이터 모달 & 서버 동기화 ----------------------- */
            const $loadUserBtn  = $('#load-user-data');      // ① “유저 데이터 불러오기”

            // 1) UUID 가 없으면 서버에서 새로 발급받기
            async function ensureMyUUID () {
              let me = localStorage.getItem('myUUID');
              if (me) return me;
               const r = await fetch('https://pocali-backend.onrender.com/api/register', {
                 method: 'POST'
               });
              me = (await r.json()).user_id;
              localStorage.setItem('myUUID', me);
              return me;
            }

            // 2) 로컬 userData → 서버 DB 업로드
            async function syncLocalDataToServer () {
              const me = localStorage.getItem('myUUID');
              if (!me) return;
              const data = JSON.parse(localStorage.getItem('userData') || '{}');
              await fetch(`https://pocali-backend.onrender.com/api/user/${me}`, {
                method : 'POST',
                headers: { 'Content-Type':'application/json' },
                body   : JSON.stringify({ data })
              });
            }

            // 3) “유저 데이터 불러오기” 버튼 클릭 시 모달 열기
            $loadUserBtn?.addEventListener('click', async () => {
              $userModal.style.display = 'none';          // 기존 모달 닫기
              const me = await ensureMyUUID();            // UUID 확보/표시
              $('#my-uuid').value    = me;
              $('#other-uuid').value = '';
              $('#uuid-msg').textContent = '';
              $('#user-data-modal').style.display = 'block';
            });
            /* ------------------------------------------------------------- */




            /* ① FAB 눌러 → ‘유저 설정’ 모달 */
            $fab.addEventListener('click', () => $userModal.style.display = 'block');
            $userModalClose.addEventListener('click', () => $userModal.style.display = 'none');
            $userModal.addEventListener('click', e => {
              if (e.target === $userModal) $userModal.style.display = 'none';
            });

            /* ② 친구 추가 – UUID 입력 모달 */
            $addFriendBtn.addEventListener('click', () => {
              $userModal.style.display = 'none';
              $friendModal.style.display = 'block';
            });
            $friendClose.addEventListener('click', () => $friendModal.style.display = 'none');
            $friendModal.addEventListener('click', e => { if (e.target === $friendModal) $friendModal.style.display = 'none'; });

            $friendConfirm.addEventListener('click', async () => {
              const me     = localStorage.getItem('myUUID');
              const friend = $('#friend-uuid').value.trim();
              if (!me || !friend) { alert('UUID를 입력하세요!'); return; }

              const ok = await fetch('https://pocali-backend.onrender.com/api/friends', {
                method : 'POST',
                headers: { 'Content-Type':'application/json' },
                body   : JSON.stringify({ me, friend })
              }).then(r => r.ok);

              if (!ok) return alert('등록 실패');

              localStorage.setItem('lastFriendUUID', friend);
              $friendModal.style.display = 'none';
              loadFriendDeck(friend);
              alert('친구 등록 완료!');
            });

            /* ③ 체크 상태 초기화 */
            $resetBtn.addEventListener('click', async () => {      // ← async 로 변경
              if (!confirm('모든 체크를 해제할까요?')) return;

              // 1) 화면-로컬 초기화
              $$('.photo-card').forEach(img => img.classList.remove('checked'));
              localStorage.removeItem('userData');
              updateCount();

              // 2) 서버에도 빈 데이터 업로드  ← ★ 이 두 줄 추가
              const me = localStorage.getItem('myUUID');
              if (me) {
                await fetch(`https://pocali-backend.onrender.com/api/user/${me}`, {
                  method : 'POST',
                  headers: { 'Content-Type':'application/json' },
                  body   : JSON.stringify({ data: {} })
                });
              }
            });

            /* ④ 시트(프린트) 모달 열기 */
            $exportBtn.addEventListener('click', () => {
              $('#user-modal').style.display = 'none';
              $('#export-modal').style.display = 'block';
            });
            

            // ➊ 상세 검색 모달 열기/닫기
              const searchDetailBtn         = document.getElementById('search-detail-btn');
              const detailSearchModal       = document.getElementById('detail-search-modal');
              const detailSearchModalClose  = document.getElementById('detail-search-modal-close');

              searchDetailBtn.addEventListener('click', () => {
                detailSearchModal.style.display = 'block';
              });
              detailSearchModalClose.addEventListener('click', () => {
                detailSearchModal.style.display = 'none';
              });
              detailSearchModal.addEventListener('click', e => {
                if (e.target === detailSearchModal) detailSearchModal.style.display = 'none';
              });
             
            /* 매우 안정적인 이미지 시트 생성 함수 - 딜레이 대폭 증가 및 단계적 처리 */
              async function generateImageSheet(cards) {
                // ── ① 전체 오버레이: 흰 배경, 내부만 스크롤, 오버플로우 전파 차단
                const overlay = document.createElement('div');
                overlay.id = "sheet-overlay"; // ID 추가
                overlay.style.cssText = `
                  position: fixed;
                  top: 0; left: 0; right: 0; bottom: 0;
                  background: #fff;
                  z-index: 9999;
                  overflow: auto;
                  padding: 20px;
                  overscroll-behavior: contain;
                `;

                // overlay 스크롤 전파 차단 (내부만 스크롤 되게)
                overlay.addEventListener('wheel', e => e.stopPropagation(), { passive: false });

                /* 4-2. 그리드 */
                const grid = document.createElement('div');
                grid.id = "sheet-grid"; // ID 추가
                grid.style.cssText = `
                  display: grid;
                  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                  gap: 12px;
                  margin-bottom: 16px;
                  background: #fff;
                  padding: 20px;
                `;
                overlay.appendChild(grid);

                // 로더 (상태 표시)
                const statusDiv = document.createElement('div');
                statusDiv.id = "sheet-status";
                statusDiv.style.cssText = `
                  position: fixed; 
                  top: 70px; 
                  left: 50%;
                  transform: translateX(-50%);
                  background: rgba(0,0,0,0.7);
                  color: white;
                  padding: 10px 15px;
                  border-radius: 5px;
                  font-weight: bold;
                  z-index: 10000;
                `;
                statusDiv.textContent = "이미지 준비 중... (0/" + cards.length + ")";
                overlay.appendChild(statusDiv);

                /* 4-4. 버튼들 */
                const btnBar = document.createElement('div');
                btnBar.style.cssText = `position:fixed; top:20px; right:20px; display:flex; gap:8px;`;
                overlay.appendChild(btnBar);

                const close = document.createElement('button');
                close.textContent = '닫기';
                close.style.cssText = `padding:8px 14px; background:#f44336; color:#fff; border:none; cursor: pointer; border-radius: 4px;`;
                close.onclick = () => document.body.removeChild(overlay);

                const save = document.createElement('button');
                save.textContent = '이미지 저장';
                save.id = "save-sheet-btn";
                save.style.cssText = `padding:8px 14px; background:#4CAF50; color:#fff; border:none; cursor: pointer; border-radius: 4px;`;
                save.disabled = true; // 초기에는 비활성화
                
                // 문서에 먼저 추가 (비동기 작업 전)
                btnBar.append(close, save);
                document.body.appendChild(overlay);

                // 이미지 로드 상태 추적
                let loadedCount = 0;
                const totalImages = cards.length;

                /* 4-3. 카드 삽입: 단계적 처리 */
                try {
                  // 이미지를 작은 배치로 나누어 로드 (시각적 피드백)
                  const BATCH_SIZE = 10;
                  for (let i = 0; i < cards.length; i += BATCH_SIZE) {
                    const batch = cards.slice(i, i + BATCH_SIZE);
                    
                    // 배치 처리 (Promise.all 사용)
                    await Promise.all(batch.map(async (orig, idx) => {
                      try {
                        // 1) 원격 이미지를 불러와 blob 으로 변환
                        const res = await fetch(orig.src);
                        const blob = await res.blob();

                        // 2) blob→ObjectURL, 이를 src 로
                        const url = URL.createObjectURL(blob);
                        const img = new Image();
                        
                        // 3) 로드 완료 추적
                        await new Promise((resolve, reject) => {
                          img.onload = () => {
                            loadedCount++;
                            statusDiv.textContent = `이미지 준비 중... (${loadedCount}/${totalImages})`;
                            resolve();
                          };
                          img.onerror = (e) => {
                            console.error("이미지 로드 오류:", e);
                            loadedCount++;
                            statusDiv.textContent = `이미지 준비 중... (${loadedCount}/${totalImages})`;
                            resolve(); // 실패해도 계속 진행
                          };
                          img.src = url;
                        });

                        // 4) 스타일 설정
                        img.style.width = '100%';
                        img.style.opacity = orig.classList.contains('checked') ? '1' : '0.4';
                        img.style.borderRadius = '0';
                        img.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                        img.setAttribute('crossorigin', 'anonymous');

                        // 5) 그리드에 추가
                        grid.appendChild(img);
                        
                      } catch (err) {
                        console.error("이미지 처리 오류:", err);
                      }
                    }));
                    
                    // 배치 사이 약간의 딜레이 (UI 반응성 유지)
                    await new Promise(resolve => setTimeout(resolve, 100));
                  }
                  
                  // 모든 이미지 로드 완료
                  statusDiv.textContent = "모든 이미지 로드 완료! (3초 후 저장 가능)";
                  
                  // 추가 안정화 대기 시간
                  await new Promise(resolve => setTimeout(resolve, 3000));
                  
                  // 이제 저장 버튼 활성화
                  save.disabled = false;
                  statusDiv.textContent = "저장 준비 완료";
                  
                } catch (err) {
                  statusDiv.textContent = "이미지 준비 중 오류 발생: " + err.message;
                  console.error("이미지 준비 오류:", err);
                }

                // 저장 버튼 핸들러
                save.onclick = async () => {
                  try {
                    // 1) 버튼 비활성화 및 상태 업데이트
                    save.disabled = true;
                    statusDiv.textContent = "캡처 준비 중...";
                    
                    // 2) 추가 안정화 대기
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // 3) 캡처 준비 - 스크롤 맨 위로
                    overlay.scrollTop = 0;
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // 4) 캡처 전 모든 이미지의 로드 상태 재확인
                    const allImages = grid.querySelectorAll('img');
                    statusDiv.textContent = `이미지 상태 확인 중... (${allImages.length}개)`;
                    
                    for (const img of allImages) {
                      if (!img.complete || img.naturalWidth === 0) {
                        console.warn("완전히 로드되지 않은 이미지 발견:", img.src);
                      }
                    }
                    
                    // 5) 캡처 진행
                    statusDiv.textContent = "캡처 진행 중... (잠시만 기다려주세요)";
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    
                    // html2canvas 옵션 최대화
                    const canvas = await html2canvas(grid, {
                      scale: 2,
                      useCORS: true,
                      allowTaint: true,
                      backgroundColor: "#ffffff",
                      logging: true,
                      imageTimeout: 0,
                      ignoreElements: (element) => {
                        // 상태 표시 등의 UI 요소는 무시
                        return element.id === 'sheet-status' || element.id === 'save-sheet-btn';
                      },
                      onclone: (clonedDoc) => {
                        // DOM 복제본에서 추가 처리
                        return new Promise(resolve => {
                          console.log("DOM 복제 완료, 추가 안정화 대기...");
                          setTimeout(resolve, 1000);
                        });
                      }
                    });
                    
                    // 6) 캡처 완료, 다운로드 준비
                    statusDiv.textContent = "캡처 완료, 이미지 저장 중...";
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // 7) 캔버스를 blob으로 직접 변환
                    canvas.toBlob(async (blob) => {
                      if (!blob) {
                        throw new Error("Canvas를 Blob으로 변환하는데 실패했습니다");
                      }
                      
                      try {
                        // 8) 다운로드 처리
                        const url = URL.createObjectURL(blob);
                        const filename = `pocalist_sheet_${Date.now()}.png`;
                        
                        // a 태그를 사용한 다운로드
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = filename;
                        a.style.display = 'none';
                        document.body.appendChild(a);
                        
                        // 클릭 이벤트를 명시적으로 발생시킴
                        a.click();
                        
                        // 약간의 딜레이 후 정리
                        await new Promise(resolve => setTimeout(resolve, 1000));
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                        
                        statusDiv.textContent = "이미지 저장 완료!";
                        save.disabled = false;
                        
                      } catch (err) {
                        statusDiv.textContent = "저장 중 오류: " + err.message;
                        console.error("저장 오류:", err);
                        save.disabled = false;
                      }
                    }, 'image/png', 1.0); // 최대 품질
                    
                  } catch (err) {
                    statusDiv.textContent = "캡처 오류: " + err.message;
                    console.error("캡처 오류:", err);
                    save.disabled = false;
                  }
                };
              }





              
            // ─── 페이징별 렌더링 함수 ─────────────────────────
             function renderNextBatch() {
            if (isRendering) return;
            isRendering = true;

            const start = currentBatch * BATCH_SIZE;
            const end   = start + BATCH_SIZE;
            const slice = allImages.slice(start, end);

            slice.forEach(image => {
              // 1) 카드 컨테이너 생성
              const container = document.createElement('div');
              container.className = 'photo-card-container';

              // 2) <img> 요소 생성
              const img = document.createElement('img');
              img.className       = 'photo-card';
              img.src             = image.url.startsWith('http')
                                    ? image.url
                                    : `https://pocali-backend.onrender.com${image.url}`;
              img.loading         = 'lazy';
              img.alt             = `${image.group} ${image.member} ${image.category} ${image.title} #${image.unique_id}`;
              img.dataset.group   = image.group;
              img.dataset.member  = image.member;
              img.dataset.category= image.category;
              img.dataset.title   = image.title;
              img.dataset.version = image.version;
              img.dataset.unique  = image.unique_id;

              // ── 로컬 저장소(userData)에 있던 체크 정보 재적용
              const saved = JSON.parse(localStorage.getItem('userData') || '{}');
              if (saved[image.unique_id]) {
                img.classList.add('checked');
              }


              // 3) 오버레이: image.type 또는 백엔드 file_type 활용
              const overlay = document.createElement('div');
              overlay.className   = 'image-overlay';
              overlay.textContent = image.type || image.file_type || '';
              container.appendChild(overlay);

              // 4) 터치·롱프레스 & 더블클릭 이벤트 바인딩
              let startTime, pressTimer;
              img.addEventListener('pointerdown', e => {
                if (viewOwner !== 'self') return;
                startTime = performance.now();
                pressTimer = setTimeout(() => showModal(img), LONG_PRESS);
              });
              img.addEventListener('pointerup', e => {
                clearTimeout(pressTimer);
                if (performance.now() - startTime < TAP_THRESHOLD) {
                  toggleCheck(img);
                }
              });
              img.addEventListener('pointerleave', () => clearTimeout(pressTimer));
              img.addEventListener('dblclick', () => {
                if (viewOwner !== 'self') return;
                toggleCheck(img);
              });
              img.addEventListener('contextmenu', e => {
                e.preventDefault();
                showModal(img);
              });

              // 5) 그리드에 추가
              container.appendChild(img);
              $grid.appendChild(container);
            });
              // — 캐시 갱신
            originalCards = Array.from($grid.querySelectorAll('.photo-card-container'));
            photoCards    = Array.from($grid.querySelectorAll('.photo-card'));

            // — 상태 갱신
            if (currentBatch === 0) {
              totalCount = allImages.length;
            }
            currentBatch++;
            updateCount();

            // — 현재 뷰(ID/카테고리)에 맞춰 재렌더
            applyFilters();

            isRendering = false; 
          }
          
            // ─── 무한 스크롤 트리거 ─────────────────────────
            window.addEventListener('scroll', () => {
              const nearBottom = window.innerHeight + window.scrollY
                               >= document.body.offsetHeight - 200;
              if (nearBottom && currentBatch * BATCH_SIZE < allImages.length) {
                renderNextBatch();
              }
            });
             });
              
          
          </script>
               
      </body>
      </html>